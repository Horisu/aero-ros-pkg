(load "package://drc_task_common/euslisp/drc-testbed-models.l")
(load "package://aero_ros_bridge/euslisp/aero-interface.l")

(defun make-drc-testbed-models-with-aero ()
  (aero-init)
  (send *aero* :locate (send (make-coords) :pos) :world)
  (send *aero* :translate (float-vector -1000 500 0))
  (send *aero* :reset-manip-pose)
  ;; Generate models                 
  (make-drc-door)
  (make-drc-hose-plug)
  (make-drc-hose-wall)
  (make-drc-stair)
  (make-drc-drill-wall)
  (make-drc-terrain)
  (make-drc-valve)
  (let ((sb (make-drc-surprise-task-box)))
    (send-all sb :translate (float-vector 12000 0 0) :world))
  ;; Align models               
  (send *stair* :translate (float-vector 8000 0 0) :world)
  (send *door* :translate (float-vector 0 0 0) :world)
  (send *hose-wall* :rotate (deg2rad -45) :z)
  (send *hose-wall* :translate (float-vector 4000 -3000 0) :world)
  (send *drill-wall* :rotate -pi/2 :z)
  (send *drill-wall* :translate (float-vector 2000 -3500 0) :world)
  (send *terrain* :translate (float-vector 5000 -1000 0) :world)
  (send *drc-valve* :rotate -pi/2 :y)
  (send *drc-valve* :rotate (deg2rad -135) :x)
  (send *drc-valve* :translate (float-vector 2000 -3500 1130) :world)
  (send *drc-valve* :translate (float-vector 0 (/ 1210 -2.0) (+ -110 -400)))
  ;; Display
  (objects (list *hose-plug* *hose-wall* *stair* *door* *drill-wall* *terrain* *drc-valve*
                 *surprise-task-shower* *surprise-task-button* *surprise-task-lever* *surprise-task-rope*))
  (send *aero* :draw-on)
  )

;; utils

(defvar *exit-flag* nil)

(defun go? (cmd &optional (real *real*))
  (let (ui) ; ui is user input
    (if (eq *exit-flag* t)
	(return-from go? "exiting process"))
    (cond ((eq real t)
	   ; if the command is not send *ri*
	   (if (and (position `*ri* cmd)
		    (position `send cmd))
	       (if (not (eq (- (position `*ri* cmd)
			       (position `send cmd)) 1))
		   (eval cmd))
	     (eval cmd))
	   (print cmd)
	   (send *irtviewer* :draw-objects)
	   (print "send real?")
	   (setq ui (read-line))
	   (if (or (equal ui "exit") (equal ui "q"))
	       (progn (setq *exit-flag* t)
		      (return-from go? (warn "detected cancelation~%"))))
	   (if (or (equal ui "no") (equal ui "n") (equal ui "nil"))
	       (return-from go? (warn "didn't send to real~%")))
	   ; rotate *ri* if command is send *aero* :rotate
	   (if (and (position `:rotate cmd)
		    (position `*aero* cmd))
	       (cond ((eq (- (position `:rotate cmd)
			     (position `*aero* cmd)) 1)
		      (send *ri* :wheel-on)
		      (send *ri* :go-pos 0 0
			    (* (eval (elt cmd (+ (position `:rotate cmd) 1)))
			       (/ 180 pi)))
		      (return-from go? t)
		      )))
	   ; if the command is send *ri*
	   (if (and (position `*ri* cmd)
		    (position `send cmd))
	       (if (eq (- (position `*ri* cmd)
			  (position `send cmd)) 1)
		   (eval cmd))
	     (send *ri* :angle-vector (send *aero* :stroke-vector)))
	   )
	  (t
	   (print cmd)
	   (setq ui (read-line))
	   (if (or (equal ui "exit") (equal ui "q"))
	       (progn (setq *exit-flag* t)
		      (return-from go? (warn "detected cancelation~%"))))
	   (if (or (equal ui "no") (equal ui "n") (equal ui "nil"))
	       (return-from go? (warn "skipping step~%")))
	   (eval cmd)
	   (send *irtviewer* :draw-objects)
	   )
	  )
    ))

(defun init-testbed (object
		     &key (pos #f(0 0 0)) (rpy (list 0 0 0)))
  (let (init-standing-coords)
    (reset-aero)
    (setq init-standing-coords
	  (make-coords :pos (float-vector (aref pos 0) (aref pos 1) 0)
		       :rpy rpy))
    (send *aero* :locate
	  (send (send (send object :copy-worldcoords)
		      :transform init-standing-coords :local)
		:pos) :world)
    (if (not (equal rpy (list 0 0 0)))
	(send *aero* :rotate
	      (car (rotation-angle
		    (send (send (send object :copy-worldcoords)
				:transform init-standing-coords :local)
			  :rot))) #f(0 0 1)))
    (if (not (= (aref pos 2) 0))
	(send *aero* :move-waist (float-vector 0 0 (aref pos 2))))
    ))

(defun reset-aero ()
  (let ((rot (send (send *aero* :lower :copy-worldcoords) :rot)))
    (send *aero* :locate (send (make-coords) :pos) :world)
    (send *aero* :rotate
	  (if (equal rot (unit-matrix 3)) 0 (- (car (rotation-angle rot))))
	  #f(0 0 1) :world)
    (send *aero* :translate (float-vector -1000 500 0))
    (setq *exit-flag* nil)
    (go? `(send *aero* :reset-manip-pose))
    ))
