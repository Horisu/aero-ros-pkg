(load "package://drc_task_common/euslisp/drc-testbed-models.l")
(load "package://aero_ros_bridge/euslisp/aero-interface.l")

(defun make-drc-testbed-models-with-aero ()
  (aero-init)
  (send *aero* :locate (send (make-coords) :pos) :world)
  (send *aero* :translate (float-vector -1000 500 0))
  (send *aero* :reset-manip-pose)
  (send *aero* :fix-leg-to-ground)
  ;; Generate models                 
  (make-drc-door)
  (make-drc-hose-plug)
  (make-drc-hose-wall)
  (make-drc-stair)
  (make-drc-drill-wall)
  (make-drc-terrain)
  (make-drc-valve)
  (let ((sb (make-drc-surprise-task-box)))
    (send-all sb :translate (float-vector 12000 0 0) :world))
  ;; Align models               
  (send *stair* :translate (float-vector 8000 0 0) :world)
  (send *door* :translate (float-vector 0 0 0) :world)
  (send *hose-wall* :rotate (deg2rad -45) :z)
  (send *hose-wall* :translate (float-vector 4000 -3000 0) :world)
  (send *drill-wall* :rotate -pi/2 :z)
  (send *drill-wall* :translate (float-vector 2000 -3500 0) :world)
  (send *terrain* :translate (float-vector 5000 -1000 0) :world)
  (send *drc-valve* :rotate -pi/2 :y)
  (send *drc-valve* :rotate (deg2rad -135) :x)
  (send *drc-valve* :translate (float-vector 2000 -3500 1130) :world)
  (send *drc-valve* :translate (float-vector 0 (/ 1210 -2.0) (+ -110 -400)))
  ;; Display
  (objects (list *hose-plug* *hose-wall* *stair* *door* *drill-wall* *terrain* *drc-valve*
                 *surprise-task-shower* *surprise-task-button* *surprise-task-lever* *surprise-task-rope*))
  (send *aero* :draw-on)
  )

;; utils

(defvar *exit-flag* nil)
(defvar *time* 5000)

(defun go? (cmd &optional (real *real*))
  (let (ui (eval? t)) ; ui is user input
    (if (eq *exit-flag* t)
	(return-from go? "exiting process"))
    (cond ((eq real t)
	   ; if the command is not send *ri*
	   (if (and (position `*ri* cmd)
		    (position `send cmd))
	       (if (eq (- (position `*ri* cmd)
			  (position `send cmd)) 1)
		   (setq eval? nil)))
	   (if (eq eval? t) (eval cmd))
	   (print cmd)
	   (send *irtviewer* :draw-objects)
	   (print "send real?")
	   (setq ui (read-line))
	   (if (or (equal ui "exit") (equal ui "q"))
	       (progn (setq *exit-flag* t)
		      (return-from go? (warn "detected cancelation~%"))))
	   (if (or (equal ui "no") (equal ui "n") (equal ui "nil"))
	       (return-from go? (warn "didn't send to real~%")))
	   ; rotate *ri* if command is send *aero* :rotate
	   (if (and (position `:rotate cmd)
		    (position `*aero* cmd))
	       (cond ((eq (- (position `:rotate cmd)
			     (position `*aero* cmd)) 1)
		      (send *ri* :wheel-on)
		      (send *ri* :go-pos 0 0
			    (* (eval (elt cmd (+ (position `:rotate cmd) 1)))
			       (/ 180 pi)))
		      (return-from go? t)
		      )))
	   ; rotate *ri* if command is send *aero* :translate
	   (if (and (position `:translate cmd)
		    (position `*aero* cmd))
	       (cond ((eq (- (position `:translate cmd)
			     (position `*aero* cmd)) 1)
		      (send *ri* :wheel-on)
		      (send *ri* :go-pos
			    (elt (elt cmd (+ (position `:translate cmd) 1)) 0)
			    (elt (elt cmd (+ (position `:translate cmd) 1)) 1)
			    0)
		      (return-from go? t)
		      )))
	   ; if the command is send *ri*
	   (if (eq eval? nil) (eval cmd)
	     (send *ri* :angle-vector (send *aero* :stroke-vector) *time*))
	   )
	  (t
	   (print cmd)
	   (setq ui (read-line))
	   (if (or (equal ui "exit") (equal ui "q"))
	       (progn (setq *exit-flag* t)
		      (return-from go? (warn "detected cancelation~%"))))
	   (if (or (equal ui "no") (equal ui "n") (equal ui "nil"))
	       (return-from go? (warn "skipping step~%")))
	   (eval cmd)
	   (send *irtviewer* :draw-objects)
	   )
	  )
    ))

(defun ctrl- (cmd)
  (print cmd)
  (setq ~coords~ :local)
  (if (position `-w cmd) (setq ~coords~ :world))
  (if (position `-l cmd) (setq ~coords~ :local))
  (case (car cmd)
	;; common
	(m
	 (if (eq (elt cmd 1) `l) (setq ~arm~ :larm))
	 (if (eq (elt cmd 1) `r) (setq ~arm~ :rarm))
	 (if (eq (elt cmd 1) `lr) (setq ~arm~ :arms))
	 (setq ~vector~ (float-vector (elt cmd 2) (elt cmd 3) (elt cmd 4)))
	 (go? `(send *aero* :upper ~arm~ :move-end-pos ~vector~ ~coords~)))
	(ra
	 (if (eq (elt cmd 1) `l) (setq ~arm~ :larm))
	 (if (eq (elt cmd 1) `r) (setq ~arm~ :rarm))
	 (if (eq (elt cmd 1) `lr) (setq ~arm~ :arms))
	 (setq ~vector~ (cond ((eq (elt cmd 2) `x) #f(1 0 0))
			      ((eq (elt cmd 2) `-x) #f(-1 0 0))
			      ((eq (elt cmd 2) `y) #f(0 1 0))
			      ((eq (elt cmd 2) `-y) #f(0 -1 0))
			      ((eq (elt cmd 2) `z) #f(0 0 1))
			      ((eq (elt cmd 2) `-z) #f(0 0 -1))))
	 (setq ~vector2~ (cond ((eq (elt cmd 3) `x) #f(1 0 0))
			       ((eq (elt cmd 3) `-x) #f(-1 0 0))
			       ((eq (elt cmd 3) `y) #f(0 1 0))
			       ((eq (elt cmd 3) `-y) #f(0 -1 0))
			       ((eq (elt cmd 3) `z) #f(0 0 1))
			       ((eq (elt cmd 3) `-z) #f(0 0 -1))))
	 (setq ~time~ (elt cmd 4))
	 (go? `(send *aero* :upper :reach-arm ~arm~
		     :toward ~vector~ :adjust ~vector2~ :stop ~time~)))
	(h
	 (if (eq (elt cmd 1) `l) (setq ~arm~ :larm))
	 (if (eq (elt cmd 1) `r) (setq ~arm~ :rarm))
	 (if (eq (elt cmd 1) `lr) (setq ~arm~ :arms))
	 (setq ~pose~ (elt cmd 2))
	 (go? `(send *aero* :hand ~arm~ ~pose~)))
	(hc
	 (if (eq (elt cmd 1) `l) (setq ~arm~ :larm))
	 (if (eq (elt cmd 1) `r) (setq ~arm~ :rarm))
	 (if (eq (elt cmd 1) `lr) (setq ~arm~ :arms))
	 (go? `(send *aero* :magic-close ~arm~)))
	(ho
	 (if (eq (elt cmd 1) `l) (setq ~arm~ :larm))
	 (if (eq (elt cmd 1) `r) (setq ~arm~ :rarm))
	 (if (eq (elt cmd 1) `lr) (setq ~arm~ :arms))
	 (go? `(send *aero* :magic-open ~arm~)))
	(hy
	 (if (eq (elt cmd 1) `l) (setq ~arm~ :larm))
	 (if (eq (elt cmd 1) `r) (setq ~arm~ :rarm))
	 (if (eq (elt cmd 1) `lr) (setq ~arm~ :arms))	 
	 (setq ~angle~ (elt cmd 2))
	 (go? `(send *aero* :hand-yaw-world ~arm~ ~angle~)))
	(mw
	 (setq ~vector~ (float-vector (elt cmd 1) (elt cmd 2) (elt cmd 3)))
	 (go? `(send *aero* :move-waist ~vector~)))
	(gp
	 (setq ~x~ (elt cmd 1))
	 (setq ~y~ (elt cmd 2))
	 (setq ~z~ (elt cmd 3))
	 (go? `(send *ri* :go-pos ~x~ ~y~ ~z~)))
	(j
	 (setq ~link~ (elt cmd 1))
	 (setq ~joint~ (elt cmd 2))
	 (setq ~angle~ (elt cmd 3))
	 (go? `(send *aero* :upper ~link~ ~joint~ :joint-angle ~angle~)))
	(s
	 (send-angle-vector))
	(t nil))
  )

(defun c-mode ()
  (dotimes (i 10000)
    (if (eq *exit-flag* t) (return-from c-mode nil))
    (setq ~ui~ (read-line))
    (if (equal ~ui~ "q")
	(return-from c-mode nil))
    (ctrl- (read-from-string ~ui~))
    ))


(defun init-testbed (object
		     &key (pos #f(0 0 0)) (rot 0))
  (reset-aero)
  (send *aero* :locate (send (send object :copy-worldcoords) :pos) :world)
  (send *aero* :fix-leg-to-ground)
  (if (not (= rot 0))
      (send *aero* :rotate rot #f(0 0 1)))
  (send *aero* :translate (float-vector (aref pos 0) (aref pos 1) 0))
  (if (not (= (aref pos 2) 0))
      (send *aero* :move-waist (float-vector 0 0 (aref pos 2))))
  (send *aero* :fix-leg-to-ground)
  )

(defun reset-env-to (object angle)
  (send *aero* :locate (send (send object :copy-worldcoords) :pos) :world)
  (send *aero* :fix-leg-to-ground)
  (if (not (= angle 0))
      (send *aero* :rotate angle #f(0 0 1)))
  (setq rot (rotation-angle
             (send (send (send *aero* :upper :torso :end-coords) :copy-worldcoords)
                   :rot)))
  (cond ((not (eq rot nil))
	 (setq rot (car rot))
	 (send *aero* :rotate rot #f(0 0 1) :world)
	 (send *drc-valve* :rotate rot #f(0 0 1) :world)))
  (objects (list *drc-valve*))
  (send *aero* :draw-on))


(defun eps-m3= (mat1 mat2)
  (dotimes (i 3)
    (if (not (eps-v= (matrix-row mat1 i) (matrix-row mat2 i)))
	(return-from eps-m3 nil)))
  t)

(defun reset-aero ()
  (let ((rot (send (send *aero* :lower :copy-worldcoords) :rot)))
    (send *aero* :locate (send (make-coords) :pos) :world)
    (send *aero* :rotate
	  (if (eps-m3= rot (unit-matrix 3)) 0 (- (car (rotation-angle rot))))
	  #f(0 0 1) :world)
    (send *aero* :translate (float-vector -1000 500 0))
    (setq *exit-flag* nil)
    (go? `(send *aero* :reset-manip-pose))
    (send *aero* :fix-leg-to-ground)
    ))
