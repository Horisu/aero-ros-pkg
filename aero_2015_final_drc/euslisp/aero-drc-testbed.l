(load "package://drc_task_common/euslisp/drc-testbed-models.l")
(load "package://aero_ros_bridge/euslisp/aero-interface.l")

(defun make-drc-testbed-models-with-aero ()
  (aero-init)
  (send *aero* :locate (send (make-coords) :pos) :world)
  (send *aero* :translate (float-vector -1000 500 0))
  (send *aero* :reset-manip-pose)
  (send *aero* :fix-leg-to-ground)
  ;; Generate models                 
  (make-drc-door)
  ;; (make-drc-hose-plug)
  ;; (make-drc-hose-wall)
  (make-drc-stair)
  ;; (make-drc-drill-wall)
  ;; (make-drc-terrain)
  (make-drc-valve)
  (let ((sb (make-drc-surprise-task-box)))
    (send-all sb :translate (float-vector 12000 0 0) :world))
  ;; Align models               
  (send *stair* :translate (float-vector 8000 0 0) :world)
  (send *door* :translate (float-vector 0 0 0) :world)
  ;; (send *hose-wall* :rotate (deg2rad -45) :z)
  ;; (send *hose-wall* :translate (float-vector 4000 -3000 0) :world)
  ;; (send *drill-wall* :rotate -pi/2 :z)
  ;; (send *drill-wall* :translate (float-vector 2000 -3500 0) :world)
  ;; (send *terrain* :translate (float-vector 5000 -1000 0) :world)
  (send *drc-valve* :rotate -pi/2 :y)
  (send *drc-valve* :rotate (deg2rad -135) :x)
  (send *drc-valve* :translate (float-vector 2000 -3500 1130) :world)
  (send *drc-valve* :translate (float-vector 0 (/ 1210 -2.0) (+ -110 -400)))
  )

;; utils

(defun init-testbed (object
		     &key (pos #f(0 0 0)) (rot 0))
  (send *aero* :locate (send (send object :copy-worldcoords) :pos) :world)
  (send *aero* :fix-leg-to-ground)
  (if (not (= rot 0))
      (send *aero* :rotate rot #f(0 0 1)))
  (send *aero* :translate (float-vector (aref pos 0) (aref pos 1) 0))
  (if (not (= (aref pos 2) 0))
      (send *aero* :move-waist (float-vector 0 0 (aref pos 2))))
  (send *aero* :fix-leg-to-ground)
  )

(defun reset-env-to (object angle)
  (send *aero* :locate (send (send object :copy-worldcoords) :pos) :world)
  (send *aero* :fix-leg-to-ground)
  (if (not (= angle 0))
      (send *aero* :rotate angle #f(0 0 1)))
  (setq rot (rotation-angle
             (send (send (send *aero* :upper :torso :end-coords) :copy-worldcoords)
                   :rot)))
  (cond ((not (eq rot nil))
	 (setq rot (car rot))
	 (send *aero* :rotate rot #f(0 0 1) :world)
	 (send object :rotate rot #f(0 0 1) :world)))
  )


(defun eps-m3= (mat1 mat2)
  (dotimes (i 3)
    (if (not (eps-v= (matrix-row mat1 i) (matrix-row mat2 i)))
	(return-from eps-m3 nil)))
  t)

(defun reset-aero ()
  (let ((rot (send (send *aero* :lower :copy-worldcoords) :rot)))
    (send *aero* :locate (send (make-coords) :pos) :world)
    (send *aero* :rotate
	  (if (eps-m3= rot (unit-matrix 3)) 0 (- (car (rotation-angle rot))))
	  #f(0 0 1) :world)
    (send *aero* :translate (float-vector -1000 500 0))
    (send *aero* :reset-manip-pose)
    (send *aero* :fix-leg-to-ground)
    ))
