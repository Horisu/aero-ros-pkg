(require :aero-upper "package://aero_ros_bridge/models/aero_upper.l")
(require :aero-lower "package://aero_ros_bridge/models/aero-lower.l")
;; some methods of AeroUpperRobot-robot is in aero-upper-interface.l
(load "package://aero_ros_bridge/euslisp/aero-upper-strokes.l")
(load "package://aero_ros_bridge/euslisp/aero-upper-interface.l")
(load "package://aero_ros_bridge/euslisp/aero-lower-strokes.l")
(load "package://aero_ros_bridge/euslisp/aero-upper-lower-angles.l")
(load "package://aero_ros_bridge/euslisp/aero-go-pos.l")

(setq wheel-radius 44.63875)

(defclass AeroRobot-robot
  :super object
  :slots ())
(defmethod AeroRobot-robot
  (:init ()
    (progn
      (if (not (boundp `*aero-upper*))
          (setq *aero-upper* (instance AeroUpperRobot-robot :init)))
      (if (not (boundp '*aero-lower*)) 
          (setq *aero-lower* (instance AeroLowerRobot-robot :init)))
      ;; move aero-upper to top location of aero-lower
      (if (boundp '*aero-lower*)
          (send *aero-upper* :newcoords
                (send (send *aero-lower* :torso :end-coords)
                      :worldcoords))
        )
      (send (send *aero-lower* :links :WAIST_LINK0) :assoc (send *aero-upper* :links :WAIST_LINK0)))
    )
  (:stroke-vector ()
    (if (and (boundp `*aero-upper*) (boundp `*aero-lower*))
        (concatenate float-vector
                     (send *aero-upper* :stroke-vector) (send *aero-lower* :stroke-vector))
      )
    )
  (:draw-on ()
    ;; executing (objects *aero*) is not going to work. Use this function instead to visualize aero in irtviewer
    (objects *aero-upper*)
    (objects *aero-lower*)
    (send *irtviewer* :draw-objects)
    )
  ;; calculate center of mass of the whole robot using center of mass of aero upper and aero lower
  (:get-com ()
    (scale (/ 1 (+ (send *aero-upper* :weight) (send *aero-lower* :weight)))
           (v+ (scale (send *aero-upper* :weight) (send *aero-upper* :centroid))
               (scale (send *aero-lower* :weight) (send *aero-lower* :centroid))))
    )
  ;; helper function for projecting a vector onto ground plane
  (:project-on-ground (in_coords)
    (float-vector (aref in_coords 0) (aref in_coords 1) 0)
    )
  
  ;; draw center of mass projected onto ground plane
  (:draw-centroid-on-ground ()
    (let ((com-on-ground (make-coords :pos (send self :project-on-ground (send self :get-com))))
          )
      (send com-on-ground :draw-on :flush t)
      com-on-ground)  
    )

  (:draw-upper-centroid-on-ground ()
    (let ((com-on-ground (make-coords :pos (send self :project-on-ground (send *aero-upper* :centroid))))
          )
      (send com-on-ground :draw-on :flush t)
      com-on-ground)  
    )
  
  (:draw-lower-centroid-on-ground ()
    (let ((com-on-ground (make-coords :pos (send self :project-on-ground (send *aero-lower* :centroid))))
          )
      (send com-on-ground :draw-on :flush t)
      com-on-ground)  
    )
  (:self-collision-check ()
    (and (send *aero-upper* :collision-check-all)
	 (send *aero-lower* :self-collision-check))
    )

  (:angle-vector (&optional (angles nil))
    (if (eq angles nil)
	(list (send *aero-upper* :angle-vector) (send *aero-lower* :angle-vector))
      (progn
	(send *aero-upper* :angle-vector (elt angles 0))
	(send *aero-lower* :angle-vector (elt angles 1))
	angles))
    )
  (:upper (&rest args)
    (eval `(send *aero-upper* ,@args))
    )
  (:lower (&rest args)
    (eval `(send *aero-lower* ,@args))
    )
  (:hand (&rest args)
    (if (null args) (return-from :hand nil))
    (let ((key (car args))
	  (nargs (cdr args)))
      (unless (keywordp key)
	(return-from :hand nil))
      (case key
	    (:arms (progn (send *aero-upper* :hand-poses :larm nargs)
			  (send *aero-upper* :hand-poses :rarm nargs)))
	    (:larm (send *aero-upper* :hand-poses :larm nargs))
	    (:rarm (send *aero-upper* :hand-poses :rarm nargs))
	    (t nil)
	    )
      )
    )

  ;; (:move-safe (arm to &key (bits 10) (world nil))
  ;;   (send *aero-upper* :move-safe arm to :bits bits :world world)
  ;;   )
  ;; (:reach-arm (arm &key (toward (float-vector 1 0 0))
  ;; 		        (adjust (float-vector 0 0 1))
  ;; 			(bits 1)
  ;; 			(stop 10))
  ;;   (send *aero-upper* :reach-arm arm
  ;; 	  :stop stop :toward toward :adjust adjust :bits bits)
  ;;   )

  (:move-waist
   (&optional (waist-velocity (float-vector 0 0 0))
	      &key (draw-objects nil))
    (let ((original-end-coords-list) original-angle-vector
	  original-coords)
      (when (< (norm waist-velocity) 3)
	(warn ";; :move-waist error: waist-velocity is too small~%")
	(return-from :move-waist nil))
      ;;
      (setf original-angle-vector (send *aero-lower* :angle-vector))
      (setf original-coords (send *aero-lower* :copy-worldcoords))
      (dolist (link (list :rarm :larm :rleg :lleg))
	(push (send *aero-lower* link :end-coords :copy-worldcoords)
	      original-end-coords-list))
      (setf original-end-coords-list (nreverse original-end-coords-list))
      (send *aero-lower* :translate waist-velocity)
      (dolist (link (list :rarm :larm :rleg :lleg))
	(unless
	    (send *aero-lower* link :inverse-kinematics
		  (car original-end-coords-list) :rotation-axis nil)
	  (warn ";; move-waist IK failed >> ~S~%" link)
	  (send *aero-lower* :angle-vector original-angle-vector)
	  (send *aero-lower* :newcoords original-coords)
	  (return-from :move-waist nil)
	  )
	(setf original-end-coords-list (cdr original-end-coords-list))
	)
      (if draw-objects (send *irtviewer* :draw-objects))
      t)
    )
  (:cog-balance-check (&optional (legs-on-grounds `(:larm :rarm :rleg :lleg)))
    (let (a b c p A1 B1 c-eval p-eval (tmp-legs))
      (setq tmp-legs legs-on-grounds)
      (setq p (send self :get-com))
      ;; check com
      (dolist (x legs-on-grounds)
	(setq c (send (send *aero-lower* (car tmp-legs) :end-coords :copy-worldcoords) :pos))
	(setq a (send (send *aero-lower* (cadr tmp-legs) :end-coords :copy-worldcoords) :pos))
	(setq b (send (send *aero-lower* (caddr tmp-legs) :end-coords :copy-worldcoords) :pos))
	(setq A1 (- (elt b 1) (elt a 1)))
	(setq B1 (- (elt b 0) (elt a 0)))
	(setq c-eval (if (> (- (* A1 (- (elt c 0) (elt a 0)))
			       (* B1 (- (elt c 1) (elt a 1)))) 0) t nil))
	(setq p-eval (if (> (- (* A1 (- (elt p 0) (elt a 0)))
			       (* B1 (- (elt p 1) (elt a 1)))) 0) t nil))
	(if (eq c-eval p-eval) nil (return-from :cog-balance-check p))
	(setq tmp-legs `(,@(cdr tmp-legs) ,(car tmp-legs)))
	)
      t)
    )
  (:rate-balance (&optional (legs-on-grounds `(:rarm :rleg :lleg)))
    (let ((com-on-ground (send self :project-on-ground (send self :get-com)))
	  (get-3foot-center #f(0 0 0))
	  (tmp-legs legs-on-grounds)
	  edge-length
	  (edge-lengths `())
	  (s 0)
	  (area 1)
	  inner-radius
	  )
      (if (eq (send self :cog-balance-check legs-on-grounds) t)
	  (progn (dolist (link legs-on-grounds)
		   (setq foot-pos (send self :project-on-ground
					(send (send *aero-lower* (car tmp-legs) :end-coords :copy-worldcoords)
					      :pos)))
		   (setq edge-length (norm (v- foot-pos
					       (send self :project-on-ground
						     (send (send *aero-lower* (cadr tmp-legs)
								 :end-coords :copy-worldcoords)
							   :pos)))))
		   (setq get-3foot-center (v+ get-3foot-center (scale edge-length foot-pos)))
		   (setq edge-lengths (push edge-length edge-lengths)) 
		   (setq tmp-legs `(,@(cdr tmp-legs) ,(car tmp-legs)))
		   )
		 (dolist (x edge-lengths)
		   (setq s (+ s x)))
		 (setq get-3foot-center (scale (/ 1.0 s) get-3foot-center))
		 (send (make-coords :pos get-3foot-center) :draw-on :flush t :size 500)
		 (setq s (/ s 2))
		 (dolist (x edge-lengths)
		   (setq area (* (- s x) area)))
		 (setq area (sqrt (* s area)))
		 (setq inner-radius (/ area s))
		 (/ inner-radius (norm (v- get-3foot-center com-on-ground)))
		 )
	0.0)
      )
    )

  (:translate (p &optional (wrt :local))
    (send *aero-lower* :translate p wrt)
    )
  (:locate (p &optional (wrt :local))
    (send *aero-lower* :locate p wrt)
    )
  (:rotate (theta axis &optional (wrt :local))
    (send *aero-lower* :rotate theta axis wrt)
    )

  (:reset-pose ()
    (send *aero-upper* :reset-pose)
    (send *aero-lower* :reset-pose)
    )
  (:reset-manip-pose ()
    (send *aero-upper* :reset-manip-pose)
    (send *aero-lower* :reset-manip-pose)
    )
  (:reset-terrain-pose ()
    (send *aero-upper* :reset-terrain-pose)
    (send *aero-lower* :reset-terrain-pose)
    )

  ;; The end coords are at the wheels' axes
  ;; The end ground coords give the point that is touching the ground
  (:end-ground-coords (limb)
    (eval `(send (send (send self :lower limb :end-coords) :copy-worldcoords) :translate (float-vector 0 0 (- wheel-radius)) :world))
    ;; (eval `(send self :lower limb :end-coords))
    )

  
  )

(provide :aero "package://aero_ros_bridge/euslisp/aero.l")
